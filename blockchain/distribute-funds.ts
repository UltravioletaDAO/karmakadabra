/**
 * Karma Kadabra V2 — Multi-Token Batch Distribution
 *
 * Distributes multiple stablecoins + native gas tokens to N wallets on a SINGLE chain.
 * Uses Disperse.app (1 TX for all recipients) where available,
 * falls back to sequential transfers where Disperse isn't deployed.
 *
 * Usage (uniform mode — same amount per wallet):
 *   npx tsx distribute-funds.ts --chain base --wallets config/wallets.json --amount 3.00 --gas 0.0005
 *   npx tsx distribute-funds.ts --chain arbitrum --tokens USDC,AUSD --amount 1.00
 *   npx tsx distribute-funds.ts --chain base --wallets config/wallets.json --dry-run
 *   npx tsx distribute-funds.ts --chain polygon --tokens USDC --usdc 5.00  # --usdc is alias for --amount
 *
 * Usage (allocation mode — per-agent randomized amounts from allocation.json):
 *   npx tsx distribute-funds.ts --chain base --allocation config/allocation.json --dry-run
 *   npx tsx distribute-funds.ts --chain polygon --allocation config/allocation.json
 */

import {
  createPublicClient,
  createWalletClient,
  http,
  parseUnits,
  parseEther,
  parseGwei,
  formatUnits,
  formatEther,
  getAddress,
  type Address,
  type Hex,
} from "viem";
import { privateKeyToAccount, nonceManager } from "viem/accounts";
import { readFileSync, writeFileSync } from "fs";
import { resolve, dirname } from "path";
import { fileURLToPath } from "url";
import { config } from "dotenv";
import {
  DISPERSE_ADDRESS,
  DISPERSE_ABI,
  ERC20_ABI,
  getChain,
  getTokens,
  getTokenSymbols,
  type TokenInfo,
} from "./lib/chains.js";
import type { WalletManifest } from "./generate-wallets.js";

const __dirname = dirname(fileURLToPath(import.meta.url));
config({ path: resolve(__dirname, "../../.env.local") });

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

interface TxResult {
  type: "approve" | "token_batch" | "native_batch" | "token_single" | "native_single";
  txHash: string;
  recipients: number;
  amount: string;
  token?: string;
  status: "confirmed" | "failed";
  error?: string;
}

interface TokenDistResult {
  symbol: string;
  address: string;
  decimals: number;
  amountPerWallet: string;
  totalAmount: string;
  txs: TxResult[];
}

/** Allocation file format (generated by generate-allocation.ts) */
interface AllocationFile {
  version: string;
  budget_usd: number;
  source_chain: string;
  generated: string;
  chains: Record<string, {
    total_usd: number;
    token: string;
    agents: Record<string, string>;
  }>;
  gas: Record<string, string>;
  bridge_plan: { source: string; targets: Record<string, string> };
  summary: Record<string, unknown>;
}

// ---------------------------------------------------------------------------
// Distribution (multi-token)
// ---------------------------------------------------------------------------

async function distribute(
  chainName: string,
  wallets: Array<{ name: string; address: Address }>,
  tokensToDistribute: TokenInfo[],
  amountPerWallet: string,
  gasPerWallet: string,
  dryRun: boolean,
  perWalletAmounts?: Record<string, string>,
  priorityFeeGwei?: number,
): Promise<{ tokenResults: TokenDistResult[]; gasResults: TxResult[] }> {
  const chainInfo = getChain(chainName);
  const tokenResults: TokenDistResult[] = [];
  const gasResults: TxResult[] = [];

  const privateKey = (process.env.WALLET_PRIVATE_KEY || process.env.PRIVATE_KEY) as Hex;
  if (!privateKey) {
    console.error("ERROR: WALLET_PRIVATE_KEY not set in .env.local");
    process.exit(1);
  }

  const account = privateKeyToAccount(privateKey, { nonceManager });

  const publicClient = createPublicClient({
    chain: chainInfo.chain,
    transport: http(chainInfo.rpcUrl),
    batch: { multicall: true },
  });

  const walletClient = createWalletClient({
    account,
    chain: chainInfo.chain,
    transport: http(chainInfo.rpcUrl),
  });

  const addresses = wallets.map((w) => w.address);
  const gasAmount = parseEther(gasPerWallet);
  const totalGas = gasAmount * BigInt(wallets.length);

  // Check native balance upfront
  const nativeBalance = await publicClient.getBalance({ address: account.address });

  // Priority fee override for L1 (makes TXs confirm faster)
  const txOverrides: Record<string, any> = {};
  if (priorityFeeGwei) {
    txOverrides.maxPriorityFeePerGas = parseGwei(String(priorityFeeGwei));
    console.log(`\n  Priority fee override: ${priorityFeeGwei} gwei`);
  }

  // L1 gets 10-minute timeout, L2s get 60s
  const isL1 = chainInfo.chainId === 1;
  const txTimeout = isL1 ? 600_000 : 60_000;
  const txConfirmations = isL1 ? 1 : 2;

  console.log(`\n=== ${chainInfo.name} (${wallets.length} wallets, ${tokensToDistribute.length} token(s)) ===`);
  console.log(`  Funder:     ${account.address}`);
  console.log(`  Native bal: ${formatEther(nativeBalance)} ${chainInfo.nativeSymbol}`);
  console.log(`  Need gas:   ${formatEther(totalGas)} ${chainInfo.nativeSymbol}`);
  console.log(`  Tokens:     ${tokensToDistribute.map((t) => t.symbol).join(", ")}`);
  if (isL1) console.log(`  Timeout:    ${txTimeout / 1000}s (Ethereum L1)`);

  // ---- Distribute each token ----
  for (const token of tokensToDistribute) {
    console.log(`\n--- ${token.symbol} (${token.name}) ---`);

    // Per-wallet amounts: use allocation map if provided, otherwise uniform
    let tokenAmounts: bigint[];
    let totalToken: bigint;
    let displayAmount: string;

    if (perWalletAmounts) {
      tokenAmounts = wallets.map((w) => {
        const amt = perWalletAmounts[w.address];
        if (!amt) throw new Error(`No allocation for ${w.address} (${w.name}) on ${chainName}`);
        return parseUnits(amt, token.decimals);
      });
      totalToken = tokenAmounts.reduce((a, b) => a + b, 0n);
      displayAmount = `varies (allocation mode)`;
    } else {
      const tokenAmount = parseUnits(amountPerWallet, token.decimals);
      totalToken = tokenAmount * BigInt(wallets.length);
      tokenAmounts = wallets.map(() => tokenAmount);
      displayAmount = amountPerWallet;
    }

    const tokenBalance = (await publicClient.readContract({
      address: token.address,
      abi: ERC20_ABI,
      functionName: "balanceOf",
      args: [account.address],
    })) as bigint;

    console.log(`  ${token.symbol} bal:  ${formatUnits(tokenBalance, token.decimals)}`);
    console.log(`  Need:       ${formatUnits(totalToken, token.decimals)}`);
    if (perWalletAmounts) {
      console.log(`  Mode:       allocation (per-agent amounts)`);
    }

    const result: TokenDistResult = {
      symbol: token.symbol,
      address: token.address,
      decimals: token.decimals,
      amountPerWallet: displayAmount,
      totalAmount: formatUnits(totalToken, token.decimals),
      txs: [],
    };

    if (tokenBalance < totalToken) {
      console.error(`  INSUFFICIENT ${token.symbol}: need ${formatUnits(totalToken, token.decimals)}, have ${formatUnits(tokenBalance, token.decimals)}`);
      tokenResults.push(result);
      continue;
    }

    if (dryRun) {
      console.log(`  [DRY RUN] Would distribute ${formatUnits(totalToken, token.decimals)} ${token.symbol}`);
      tokenResults.push(result);
      continue;
    }

    // --- Execute token distribution ---
    if (chainInfo.disperseAvailable) {
      console.log(`  Using Disperse.app (batch mode)...`);

      // 1. Approve (with 10% buffer to avoid race conditions on fast chains)
      const approveAmount = totalToken + (totalToken / 10n);
      console.log(`  [1/2] Approving ${formatUnits(approveAmount, token.decimals)} ${token.symbol}...`);
      try {
        const approveTx = await walletClient.writeContract({
          address: token.address,
          abi: ERC20_ABI,
          functionName: "approve",
          args: [DISPERSE_ADDRESS, approveAmount],
          ...txOverrides,
        });
        await publicClient.waitForTransactionReceipt({
          hash: approveTx,
          confirmations: txConfirmations,
          timeout: txTimeout,
        });
        console.log(`        TX: ${approveTx}`);
        result.txs.push({ type: "approve", txHash: approveTx, recipients: 1, amount: formatUnits(approveAmount, token.decimals), token: token.symbol, status: "confirmed" });
      } catch (err: any) {
        console.error(`  APPROVE FAILED: ${err.message}`);
        result.txs.push({ type: "approve", txHash: "", recipients: 1, amount: "0", token: token.symbol, status: "failed", error: err.message });
        tokenResults.push(result);
        continue;
      }

      // 2. Disperse token
      console.log(`  [2/2] Dispersing ${token.symbol} to ${addresses.length} wallets...`);
      try {
        const tokenTx = await walletClient.writeContract({
          address: DISPERSE_ADDRESS,
          abi: DISPERSE_ABI,
          functionName: "disperseToken",
          args: [token.address, addresses, tokenAmounts],
          ...txOverrides,
        });
        await publicClient.waitForTransactionReceipt({
          hash: tokenTx,
          confirmations: txConfirmations,
          timeout: txTimeout,
        });
        console.log(`        TX: ${tokenTx}`);
        result.txs.push({ type: "token_batch", txHash: tokenTx, recipients: addresses.length, amount: formatUnits(totalToken, token.decimals), token: token.symbol, status: "confirmed" });
      } catch (err: any) {
        console.error(`  ${token.symbol} DISPERSE FAILED: ${err.message}`);
        result.txs.push({ type: "token_batch", txHash: "", recipients: 0, amount: "0", token: token.symbol, status: "failed", error: err.message });
      }
    } else {
      // SEQUENTIAL FALLBACK
      console.log(`  Using sequential transfers (Disperse not available on ${chainName})...`);

      for (let i = 0; i < wallets.length; i++) {
        const walletAmount = tokenAmounts[i];
        try {
          console.log(`  [${token.symbol} ${i + 1}/${wallets.length}] ${formatUnits(walletAmount, token.decimals)} -> ${wallets[i].name}`);
          const tx = await walletClient.writeContract({
            address: token.address,
            abi: ERC20_ABI,
            functionName: "transfer",
            args: [wallets[i].address, walletAmount],
          });
          await publicClient.waitForTransactionReceipt({ hash: tx });
          result.txs.push({ type: "token_single", txHash: tx, recipients: 1, amount: formatUnits(walletAmount, token.decimals), token: token.symbol, status: "confirmed" });
        } catch (err: any) {
          console.error(`    FAILED: ${err.message}`);
          result.txs.push({ type: "token_single", txHash: "", recipients: 1, amount: "0", token: token.symbol, status: "failed", error: err.message });
        }
      }
    }

    tokenResults.push(result);
  }

  // ---- Distribute native gas (once, after all tokens) ----
  if (gasAmount > 0n) {
    const gasBuffer = parseEther("0.0005"); // ~$1.25 buffer for the Disperse TX itself
    if (nativeBalance < totalGas + gasBuffer) {
      console.error(`\n  INSUFFICIENT NATIVE: need ${formatEther(totalGas + gasBuffer)}, have ${formatEther(nativeBalance)}`);
    } else if (dryRun) {
      console.log(`\n  [DRY RUN] Would distribute ${formatEther(totalGas)} ${chainInfo.nativeSymbol}`);
    } else {
      console.log(`\n--- ${chainInfo.nativeSymbol} (gas) ---`);

      if (chainInfo.disperseAvailable) {
        console.log(`  Dispersing ${chainInfo.nativeSymbol} to ${addresses.length} wallets...`);
        const gasAmounts = wallets.map(() => gasAmount);
        try {
          const nativeTx = await walletClient.writeContract({
            address: DISPERSE_ADDRESS,
            abi: DISPERSE_ABI,
            functionName: "disperseEther",
            args: [addresses, gasAmounts],
            value: totalGas,
            ...txOverrides,
          });
          await publicClient.waitForTransactionReceipt({
            hash: nativeTx,
            confirmations: txConfirmations,
            timeout: txTimeout,
          });
          console.log(`        TX: ${nativeTx}`);
          gasResults.push({ type: "native_batch", txHash: nativeTx, recipients: addresses.length, amount: formatEther(totalGas), status: "confirmed" });
        } catch (err: any) {
          console.error(`  NATIVE DISPERSE FAILED: ${err.message}`);
          gasResults.push({ type: "native_batch", txHash: "", recipients: 0, amount: "0", status: "failed", error: err.message });
        }
      } else {
        for (let i = 0; i < wallets.length; i++) {
          try {
            console.log(`  [GAS ${i + 1}/${wallets.length}] ${formatEther(gasAmount)} -> ${wallets[i].name}`);
            const tx = await walletClient.sendTransaction({
              to: wallets[i].address,
              value: gasAmount,
            });
            await publicClient.waitForTransactionReceipt({ hash: tx });
            gasResults.push({ type: "native_single", txHash: tx, recipients: 1, amount: formatEther(gasAmount), status: "confirmed" });
          } catch (err: any) {
            console.error(`    FAILED: ${err.message}`);
            gasResults.push({ type: "native_single", txHash: "", recipients: 1, amount: "0", status: "failed", error: err.message });
          }
        }
      }
    }
  }

  // Summary
  const allTxs = [...tokenResults.flatMap((t) => t.txs), ...gasResults];
  const success = allTxs.filter((r) => r.status === "confirmed").length;
  console.log(`\n  Done: ${success}/${allTxs.length} TXs confirmed on ${chainName}`);

  return { tokenResults, gasResults };
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

async function main() {
  const args = process.argv.slice(2);

  const chainName = args.includes("--chain") ? args[args.indexOf("--chain") + 1] : "base";
  const dryRun = args.includes("--dry-run");

  // Priority fee in gwei (e.g. --priority-fee 5 for 5 gwei tip — faster L1 confirmation)
  const priorityFeeGwei = args.includes("--priority-fee")
    ? parseFloat(args[args.indexOf("--priority-fee") + 1])
    : undefined;

  // --- Allocation mode: per-agent amounts from allocation.json ---
  const allocationFile = args.includes("--allocation")
    ? resolve(__dirname, args[args.indexOf("--allocation") + 1])
    : null;

  if (allocationFile) {
    let allocation: AllocationFile;
    try {
      allocation = JSON.parse(readFileSync(allocationFile, "utf-8"));
    } catch {
      console.error(`ERROR: Cannot read allocation file ${allocationFile}`);
      process.exit(1);
    }

    const chainAllocation = allocation.chains[chainName];
    if (!chainAllocation) {
      console.error(`ERROR: Chain "${chainName}" not found in allocation. Available: ${Object.keys(allocation.chains).join(", ")}`);
      process.exit(1);
    }

    // Derive wallets from allocation keys
    const agentAddresses = Object.keys(chainAllocation.agents);
    const walletsFile = args.includes("--wallets")
      ? resolve(__dirname, args[args.indexOf("--wallets") + 1])
      : resolve(__dirname, "config", "wallets.json");

    let manifest: WalletManifest;
    try {
      manifest = JSON.parse(readFileSync(walletsFile, "utf-8"));
    } catch {
      console.error(`ERROR: Cannot read ${walletsFile}. Run generate-wallets.ts first.`);
      process.exit(1);
    }

    // Build wallet list in the same order as allocation, with names from manifest
    const nameMap = new Map(manifest.wallets.map((w) => [getAddress(w.address), w.name]));
    const wallets = agentAddresses.map((addr) => ({
      name: nameMap.get(getAddress(addr)) || addr.slice(0, 10),
      address: getAddress(addr) as Address,
    }));

    // Per-wallet amounts map (checksummed addresses)
    const perWalletAmounts: Record<string, string> = {};
    for (const [addr, amt] of Object.entries(chainAllocation.agents)) {
      perWalletAmounts[getAddress(addr)] = amt;
    }

    // Token: allocation specifies one token per chain
    const tokenSymbol = chainAllocation.token || "USDC";
    const tokensToDistribute = getTokens(chainName).filter((t) => t.symbol === tokenSymbol);
    if (tokensToDistribute.length === 0) {
      console.error(`ERROR: Token ${tokenSymbol} not available on ${chainName}`);
      process.exit(1);
    }

    // Gas from allocation or fallback
    const gasPerWallet = allocation.gas[chainName] || "0.0005";
    const totalUsd = Object.values(chainAllocation.agents).reduce((a, b) => a + parseFloat(b), 0);

    console.log(`\nAllocation mode: distributing to ${wallets.length} wallets on ${chainName}`);
    console.log(`  Allocation:   ${allocationFile}`);
    console.log(`  Token:        ${tokenSymbol}`);
    console.log(`  Total:        $${totalUsd.toFixed(2)}`);
    console.log(`  Gas/wallet:   ${gasPerWallet}`);
    if (dryRun) console.log(`  ** DRY RUN **`);

    const { tokenResults, gasResults } = await distribute(
      chainName,
      wallets,
      tokensToDistribute,
      "0", // unused in allocation mode
      gasPerWallet,
      dryRun,
      perWalletAmounts,
      priorityFeeGwei,
    );

    const report = {
      timestamp: new Date().toISOString(),
      chain: chainName,
      mode: "allocation",
      allocationFile,
      walletCount: wallets.length,
      totalUsd,
      gasPerWallet,
      dryRun,
      tokens: tokenResults,
      gas: gasResults,
    };
    const reportFile = resolve(__dirname, `report-distribute-${chainName}-${Date.now()}.json`);
    writeFileSync(reportFile, JSON.stringify(report, null, 2));
    console.log(`\nReport: ${reportFile}`);
    return;
  }

  // --- Uniform mode (original behavior) ---
  const walletsFile = args.includes("--wallets")
    ? args[args.indexOf("--wallets") + 1]
    : resolve(__dirname, "config", "wallets.json");

  // --amount is the primary flag, --usdc is a backward-compat alias
  const amountPerWallet = args.includes("--amount")
    ? args[args.indexOf("--amount") + 1]
    : args.includes("--usdc")
      ? args[args.indexOf("--usdc") + 1]
      : "1.00";

  const gasPerWallet = args.includes("--gas") ? args[args.indexOf("--gas") + 1] : "0.0005";

  // --tokens flag: comma-separated list, or default to ALL tokens on chain
  const availableSymbols = getTokenSymbols(chainName);
  let selectedSymbols: string[];

  if (args.includes("--tokens")) {
    const raw = args[args.indexOf("--tokens") + 1];
    selectedSymbols = raw.split(",").map((s) => s.trim().toUpperCase());
    // Validate
    for (const sym of selectedSymbols) {
      if (!availableSymbols.includes(sym)) {
        console.error(`ERROR: Token ${sym} not available on ${chainName}. Available: ${availableSymbols.join(", ")}`);
        process.exit(1);
      }
    }
  } else {
    selectedSymbols = availableSymbols;
  }

  const tokensToDistribute = getTokens(chainName).filter((t) => selectedSymbols.includes(t.symbol));

  // Load wallets
  let manifest: WalletManifest;
  try {
    manifest = JSON.parse(readFileSync(walletsFile, "utf-8"));
  } catch {
    console.error(`ERROR: Cannot read ${walletsFile}. Run generate-wallets.ts first.`);
    process.exit(1);
  }

  const wallets = manifest.wallets.map((w) => ({
    name: w.name,
    address: getAddress(w.address) as Address,
  }));

  console.log(`\nDistributing to ${wallets.length} wallets on ${chainName}`);
  console.log(`  Tokens:       ${tokensToDistribute.map((t) => t.symbol).join(", ")}`);
  console.log(`  Amount/token: ${amountPerWallet}`);
  console.log(`  Gas/wallet:   ${gasPerWallet}`);
  if (dryRun) console.log(`  ** DRY RUN **`);

  const { tokenResults, gasResults } = await distribute(
    chainName,
    wallets,
    tokensToDistribute,
    amountPerWallet,
    gasPerWallet,
    dryRun,
    undefined,
    priorityFeeGwei,
  );

  // Save report
  const report = {
    timestamp: new Date().toISOString(),
    chain: chainName,
    walletCount: wallets.length,
    amountPerWallet,
    gasPerWallet,
    dryRun,
    tokens: tokenResults,
    gas: gasResults,
  };
  const reportFile = resolve(__dirname, `report-distribute-${chainName}-${Date.now()}.json`);
  writeFileSync(reportFile, JSON.stringify(report, null, 2));
  console.log(`\nReport: ${reportFile}`);
}

main().catch(console.error);
